// Generated by CoffeeScript 1.6.2
(function() {
  var Compilation, EventEmitter, compile, cons, isArray, parseJSON, saveAs, tasks;

  parseJSON = (typeof JSON !== "undefined" && JSON !== null ? JSON.parse : void 0) || $.parseJSON;

  isArray = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  saveAs = function(name, text) {
    var a, blob, event;

    if (!document.createElementNS) {
      return false;
    }
    a = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
    if (!("download" in a)) {
      return false;
    }
    blob = new window.Blob([text], {
      type: "text/plain;charset=utf8"
    });
    a.href = window.URL.createObjectURL(blob);
    a.download = name;
    event = document.createEvent("MouseEvents");
    event.initMouseEvent("click", 1, 0, window, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
    a.dispatchEvent(event);
    return true;
  };

  $(function() {
    return $("<iframe name='compileJsDownloadTarget'></iframe>").hide().appendTo("body");
  });

  EventEmitter = (function() {
    function EventEmitter(parent) {
      this.parent = parent != null ? parent : window;
      this.events = {};
    }

    EventEmitter.prototype.on = function(event, callback) {
      if (!this.events[event]) {
        this.events[event] = [];
      }
      this.events[event].push(callback);
      return this.parent;
    };

    EventEmitter.prototype.emit = function() {
      var args, callback, callbacks, event, _i, _len;

      args = Array.prototype.slice.call(arguments);
      event = args.shift();
      callbacks = this.events[event];
      if (!callbacks) {
        return;
      }
      for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
        callback = callbacks[_i];
        callback.apply(this.parent, args);
      }
      return this.parent;
    };

    return EventEmitter;

  })();

  Compilation = (function() {
    function Compilation() {
      this.values = {};
      this._ee = new EventEmitter(this);
    }

    Compilation.prototype._ajax = function(url, callback) {
      var m,
        _this = this;

      m = url.match(/https?:\/\/[^\/]+/);
      if (!m || m[0] === window.location.origin) {
        return $.ajax({
          url: url,
          dataType: 'text'
        }).always(function(body, status, msg) {
          if (status === 'error') {
            return _this._error("ajax: " + msg);
          }
          return callback(body);
        });
      } else {
        this._log("jsonp request for: " + url);
        return $.ajax({
          url: 'http://compilejs.jpillora.com/retrieve',
          data: {
            url: url
          },
          dataType: 'jsonp'
        }).always(function(obj, status, msg) {
          if (status === 'error') {
            return _this._error("ajax: " + msg);
          }
          if (obj.error) {
            return _this._error("ajax: " + obj.error);
          }
          return callback(obj.body);
        });
      }
    };

    Compilation.prototype._getAll = function(names, callback) {
      var i, name, values, _fn, _i, _len,
        _this = this;

      values = [];
      _fn = function(i) {
        return _this.get(name, function(val) {
          values[i] = val;
          if (names.length === values.length) {
            return callback(values);
          }
        });
      };
      for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
        name = names[i];
        _fn(i);
      }
      return this;
    };

    Compilation.prototype.get = function(name, callback) {
      var doCallback, timeout,
        _this = this;

      if (isArray(name)) {
        return this._getAll(name, callback);
      }
      if (typeof name !== 'string') {
        return this._error("get: name should be a string");
      }
      timeout = setTimeout(function() {
        return _this._warn("get: timeout waiting for '" + name + "'");
      }, 8 * 1000);
      doCallback = function() {
        _this._ee.emit("get:value:" + name);
        clearTimeout(timeout);
        return callback(_this.values[name]);
      };
      if (this.values[name]) {
        setTimeout(doCallback, 0);
      } else {
        this._ee.on("set:value:" + name, doCallback);
      }
      return this;
    };

    Compilation.prototype.set = function(name, str) {
      var doCallback,
        _this = this;

      this._log("setting " + name);
      if (this.values[name]) {
        return this._error("set: '" + name + "' already exists");
      }
      doCallback = function(val) {
        _this.values[name] = val;
        return _this._ee.emit("set:value:" + name);
      };
      if (/[\s\{\}]/.test(str)) {
        setTimeout((function() {
          return doCallback(str);
        }), 0);
      } else {
        this._ajax(str, doCallback);
      }
      return this;
    };

    Compilation.prototype.download = function(name) {
      var _this = this;

      this._log("downloading " + name);
      this.get(name, function(val) {
        var form;

        if (saveAs("" + name + ".js", val)) {
          _this._log("native download");
          return;
        }
        form = $("<form method='post' target='compileJsDownloadTarget'></form>").hide().attr('action', "http://compilejs.jpillora.com/download?filename=" + (encodeURIComponent(name)) + ".js").append($("<textarea name='__compilejsDownload'></textarea>").text(val)).appendTo("body").submit();
        setTimeout(form.remove, 1000);
        return _this._log("replay download");
      });
      return this;
    };

    Compilation.prototype.run = function(name, config) {
      var checkScripts, gotScripts, gotSrc, load, script, task, wait, _ref,
        _this = this;

      task = tasks[name];
      if (!task) {
        return this._error("run: Missing task '" + name + "'");
      }
      gotSrc = function(src) {
        config.src = src;
        if (task.init && !task._initd) {
          task.init();
          task._initd = true;
        }
        return task.run.call(_this, config, function(err) {
          if (err) {
            return _this._error("run: " + name + ": " + err);
          }
        });
      };
      gotScripts = function() {
        if (config.src) {
          return _this.get(config.src, gotSrc);
        } else {
          return setTimeout(gotSrc, 0);
        }
      };
      checkScripts = function() {
        if (wait === load) {
          return gotScripts();
        }
      };
      wait = 0;
      load = 0;
      if ($.isPlainObject(task.fetch)) {
        _ref = task.fetch;
        for (name in _ref) {
          script = _ref[name];
          if (window[name]) {
            continue;
          }
          wait++;
          $.getScript(script, function() {
            load++;
            return checkScripts();
          });
        }
      }
      checkScripts();
      return this;
    };

    Compilation.prototype.options = function() {
      throw "Not implemented";
    };

    return Compilation;

  })();

  cons = {};

  $.each(['log', 'error', 'warn'], function(i, fn) {
    cons[fn] = function() {
      if (/MSIE/.test(window.navigator.userAgent)) {
        return;
      }
      return console[fn].apply(console, ['Compile.js:'].concat(Array.prototype.slice.call(arguments)));
    };
    Compilation.prototype[fn] = function(callback) {
      this._ee.on(fn, callback);
      return this;
    };
    return Compilation.prototype['_' + fn] = function(str) {
      cons[fn](str);
      this._ee.emit(fn, str);
      return this;
    };
  });

  tasks = {};

  compile = {
    tasks: tasks,
    task: function(name, def) {
      if (tasks[name]) {
        cons.warn("task: '" + name + "' already exists");
      }
      if (typeof def === "function") {
        def = {
          run: def
        };
      } else if (!def || typeof def.run !== "function") {
        return cons.error("task: '" + name + "' Missing run function");
      }
      return tasks[name] = def;
    }
  };

  $.each(['log', 'error', 'warn', 'get', 'set', 'download', 'run'], function(i, fn) {
    return compile[fn] = function() {
      var inst;

      inst = new Compilation;
      return inst[fn].apply(inst, arguments);
    };
  });

  compile.task('concat', function(config, callback) {
    return this.set(config.dest, typeof config.src === 'string' ? config.src : void 0, $.isArray(config.src(config.src.join(config.sep || '\n'))) ? void 0 : void 0, null);
  });

  if (typeof exports === "object") {
    module.exports = compile;
  } else if (typeof define === "function" && define.amd) {
    define(function() {
      return compile;
    });
  } else {
    window.compile = compile;
  }

}).call(this);
